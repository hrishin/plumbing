---
apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: pipeline-test
spec:
  inputs:
    resources:
      - name: plumbing-git
        type: git
      - name: tektoncd-pipeline-git
        type: git
    params:
    - name: IMAGE_NAME
      description: The bootstrap image with all the tools needed
    - name: UPLOADER_HOST
      description: GO Simple Uploader hostname
    - name: CLUSTER_NAME
      description: Cluster name
  steps:
  - name: go-tests
    env:
    - name: UPLOADER_USERNAME
      valueFrom:
        secretKeyRef:
          name: openshift-install
          key: uploader-username
    - name: UPLOADER_PASSWORD
      valueFrom:
        secretKeyRef:
          name: openshift-install
          key: uploader-password
    image: $(inputs.params.IMAGE_NAME)
    workingDir: $(inputs.resources.tektoncd-pipeline-git.path)
    script: |
      #!/usr/bin/env bash
      set -eu
      TIMESTAMP=$(date '+%Y%m%d-%Hh%M-%S')
      NS=tekton-pipeline-tests-${TIMESTAMP}
      failed=0
      export BUILD_NUMBER=1

      mkdir -p ${HOME}/.kube
      curl -o ${HOME}/.kube/config \
           -u ${UPLOADER_USERNAME}:${UPLOADER_PASSWORD} \
           $(inputs.params.UPLOADER_HOST)/private/CI/$(inputs.params.CLUSTER_NAME)/kubeconfig
      export KUBECONFIG=${HOME}/.kube/config

      oc new-project ${NS}

      source test/e2e-common.sh

      # Run the integration tests
      header "Running Go e2e tests"

      go test -v -failfast -count=1 -tags=e2e \
        -ldflags '-X github.com/tektoncd/pipeline/test.missingKoFatal=false -X github.com/tektoncd/pipeline/test.skipRootUserTests=true' \
        ./test -timeout=20m --kubeconfig=${KUBECONFIG}  || failed=1

      (( failed )) && fail_test

      echo "Cleaning up Test NS: ${NS}"
      kubectl delete ns ${NS}
      echo "Cleaning up arendelle namespaces"
      kubectl get ns | grep arendelle|awk '{print $1}'|xargs kubectl delete ns
      success
  - name: yaml-tests
    env:
    - name: UPLOADER_USERNAME
      valueFrom:
        secretKeyRef:
          name: openshift-install
          key: uploader-username
    - name: UPLOADER_PASSWORD
      valueFrom:
        secretKeyRef:
          name: openshift-install
          key: uploader-password
    image: $(inputs.params.IMAGE_NAME)
    workingDir: $(inputs.resources.tektoncd-pipeline-git.path)
    script: |
      #!/usr/bin/env bash
      set -eu
      # pipelinerun does way way too much kubernetes specifics stuff with a cluster-admin...
      # TODO: sidecar-ready is failing due of readinessprobe not doign its work, let's investigate this later
      declare -ar SKIP_YAML_TEST=(pipelinerun sidecar-ready
                                  git-volume dind-sidecar pull-private-image
                                  build-gcs-targz build-gcs-zip gcs-resource)

      TIMESTAMP=$(date '+%Y%m%d-%Hh%M-%S')
      NS=tekton-pipeline-tests-yaml-${TIMESTAMP}
      failed=0
      export BUILD_NUMBER=1

      mkdir -p ${HOME}/.kube
      curl -o ${HOME}/.kube/config \
           -u ${UPLOADER_USERNAME}:${UPLOADER_PASSWORD} \
           $(inputs.params.UPLOADER_HOST)/private/CI/$(inputs.params.CLUSTER_NAME)/kubeconfig

      oc new-project ${NS}

      # We are adding the serviceAccount builder to priviliged so we can run kaniko tasks..
      oc adm policy add-scc-to-user privileged -z builder

      # We are applying patches if any
      if [[ -d $(inputs.resources.plumbing-git.path)/CI/tasks/components/pipeline/patches ]];then
        for patch in $(inputs.resources.plumbing-git.path)/CI/tasks/components/pipeline/patches/*;do
            [[ ${patch} != *patch && ${patch} != *diff ]] && continue
            echo "Applying patch $(basename ${patch})"
            patch -p1 -i ${patch}
        done
      fi

      # We do this so cloudevent would know where to go for our namespace...
      sed -i  "s/sink.default/sink.${NS}/"  $(inputs.resources.tektoncd-pipeline-git.path)/examples/taskruns/cloud-event.yaml

      # We should find a way to exclude install_pipeline_crd and be able to run
      # e2e-tests.sh directly
      source test/e2e-common.sh

      MAX_CONCURRENT_PIPELINE=3

      function run_batched_yaml_tests() {
          local resource=$1
          echo ">> Creating resources ${resource}"

          cnt=1
          runtasks=()

          # Applying the resources, either *taskruns or * *pipelineruns
          for file in $(find ${REPO_ROOT_DIR}/examples/${resource}s -name '*.yaml' -not -path "*/no-ci/*" | sort); do
              skipit=False
              reltestname=$(basename $file|sed 's/.yaml//')
              for skip in ${SKIP_YAML_TEST[@]};do
                  [[ ${reltestname} == ${skip} ]] && skipit=True
              done
              [[ ${skipit} == True ]] && {
                  echo ">>> INFO: skipping yaml test ${reltestname}"
                  continue
              }
              echo ">>> Creating ${resource}/${reltestname}"
              runtasks+=(${reltestname})
              kubectl delete -n ${NS} -f ${file} >/dev/null 2>/dev/null || true
              kubectl create -n ${NS} -f ${file} >/dev/null || return 1
              [[ ${cnt} == ${MAX_CONCURRENT_PIPELINE} ]] && {
                  if ! run_tests ${1}; then
                      echo "FAILURE: "
                      return 1
                  fi
                  echo "Done!!"
                  sleep 2
                  cnt=1
                  for yamltest in ${runtasks[@]};do
                      echo ">> Cleaning up ${resource}/${yamltest}"
                      # We have so many OOMKILLED in that cluster that i rather cleanup as much as possible
                      kubectl delete ${resource} -n ${NS} --all >/dev/null || true
                      kubectl delete all -n ${NS} --all >/dev/null || true
                      kubectl delete -n ${NS} -f ${REPO_ROOT_DIR}/examples/${resource}s/${yamltest}.yaml 2>/dev/null >/dev/null || true
                  done
                  runtasks=()
              }
              (( cnt+=1 ))
          done
          return 0
      }


      failed=0
      for test in taskrun pipelinerun; do
        header "Running YAML e2e tests for ${test}s"
        if ! run_batched_yaml_tests ${test}; then
          echo ">>> ERROR: one or more YAML tests failed"
          output_yaml_test_results ${test}
          output_pods_logs ${test}
          failed=1
        fi
      done

      (( failed )) && fail_test

      kubectl delete ns ${NS}
      success
